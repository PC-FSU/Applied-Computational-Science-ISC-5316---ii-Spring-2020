#include<iostream>
#include<random>
#include<math.h>
#include<vector>
#include<algorithm>
#include<fstream>
#include <iterator>
#include <bits/stdc++.h>
#include "mpi.h"

MPI_Status status;

double Fun(double x, double y)
{
    double temp = 0;
    temp = 1 + pow(sin(x),2) + pow(sin(y),2) - 0.1*exp(-pow(x,2)-pow(y,2));
    return temp; 
}

void get_Cloud(double * coords,int row, int column)
{
 
    static std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    std::uniform_real_distribution<> dis(-20, 20);
    
    for (int i = 0; i < row; i++) 
    {
        // Use dis to transform the random unsigned int generated by gen into a 
        // double in [20, 20). Each call to dis(gen) generates a new random double
        coords[i*column]  = dis(gen); //X_cord
        coords[i*column + 1] = dis(gen); //Y_cord
    }
}

void get_simplex(int * index_list,int n,int N, int my_rank)
{
    static std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    std::uniform_real_distribution<> dis(0, N-1);
  for(int i=0;i<=n;i++)
  {
    index_list[i] = std::round(dis(gen));
  }
}



double get_max (double * val, int row) {
    int max_index = 0;
    for(int i = 1; i < row; i++) {
        if(val[i] > val[max_index]) {
            max_index = i;
        }
    }
    return max_index;
}

void Find_new(double * global_param,double * P_param,double * coords,double * val,int * index_list,int column,int row, int my_rank)
{   
    double val_1 = 0,val_2=0,val_3=0,MAX,x_centroid = 0,y_centroid = 0,P_x,P_y,P_val;
    int min_index = 0,max_index = 0,status=0;
    val_1  = val[index_list[0]];
    val_2  = val[index_list[1]];
    val_3  = val[index_list[2]];
  
    MAX = std::max({val_1,val_2,val_3});
    
    //To find the index of max element
    for(int i = 0;i<=column;i++)
    {
        if(index_list[i]==MAX)
        {
            max_index = i;
        }
    }
   
   for (int i =0;i<=column;i++)
   { 
          if(i != max_index)
          {
            x_centroid += coords[index_list[i]*column];
            y_centroid += coords[index_list[i]*column + 1];
          }
   }

   x_centroid = x_centroid/(column); y_centroid = y_centroid/(column);
   P_x = 2*x_centroid -  coords[index_list[max_index]*column];
   P_y = 2*y_centroid -  coords[index_list[max_index]*column + 1];
   P_val = Fun(P_x,P_y);

   val_1 = get_max(val,row);    // Reusing val_1 to find the index of global maxima 
   val_2 = val[(int)val_1];       //Resuing val_2 to find the value of global maxima 

   global_param[0] = val_1;
   global_param[1] = val_2;
   P_param[0] = P_x;
   P_param[1] = P_y;
   P_param[2] = P_val;
   //std::cout<<val_2<<"\n";
}

void sort_cloud(double * coords,double * val, int N)
{
    std::vector<std::pair<double,int> > vp;
    for (int i = 0;i<N;i++)
    {
        vp.push_back(std::make_pair(val[i],i));
    }

    //Sorting Pair Vector
    std::sort(vp.begin(),vp.end());

    double temp_coords[N][2] = {0};   /*to save sorted coords*/
    double temp_val[N]       = {0};        /*to save sorted function value*/

    for (int i = 0; i < vp.size(); i++)
    { 
      temp_coords[i][0] = coords[vp[i].second*2];
      temp_coords[i][1] = coords[vp[i].second*2 + 1];
      temp_val[i]       = vp[i].first; 
    }
     
    for (int i = 0; i < vp.size(); i++)
    { 
      coords[i*2]     = temp_coords[i][0];
      coords[i*2 + 1] = temp_coords[i][1];
      val[i]          = temp_val[i];
    }
}

int main(int argc, char** argv)
{
    int         N = 100;
    int         n=2;
    int         flag=0;
    int         iteration = 10000;
    int         total_iterations=0;
    double      coords[N][n] = {0};
    double      val[N] = {0};
    int         index_list[n+1] = {0}; 
    int         my_rank;   /* My process rank           */
    int         p;         /* The number of processes   */
    float       a;         /* Left endpoint             */
    float       b;         /* Right endpoint            */

    get_Cloud((double *)coords,N,n);
    
     /* Let the system do what it needs to start up MPI */
    MPI_Init(NULL,NULL);
    /* Get my process rank */
    MPI_Comm_rank(MPI_COMM_WORLD, &my_rank);
    /* Find out how many processes are being used */
    MPI_Comm_size(MPI_COMM_WORLD, &p);
    int Work_load = N/p;

    if(my_rank !=  p)
    {
        for(int i = Work_load*my_rank;i<Work_load*(my_rank+1);i++)
        {
            val[i] = Fun(coords[i][0],coords[i][1]);
        }
    }
    else
    {
        for(int i = Work_load*my_rank;i<N;i++)
        {
            val[i] = Fun(coords[i][0],coords[i][1]);
        }
    }
  
    double temp_val[N] = {0};
    MPI_Allreduce(val, temp_val, N, MPI_DOUBLE,MPI_SUM,MPI_COMM_WORLD);
    
    for(int i = 0;i<N;i++)
        {
            val[i] = temp_val[i];
        }
     sort_cloud((double *)coords,val,N);
     
    for(int i = my_rank;i<16;i = i + p)
    {   

        int status = 0;
        double global_param[2] = {0},P_param[3]={0};             /* global_param[2] = {max_index,max_value} */
        get_simplex(index_list,n,N,my_rank);                     /* P_param[3] = {P_X_coordinate,P_Y_coordinate,P_functon_value}*/  
        Find_new(global_param,P_param,(double *)coords,val,index_list,n,N,my_rank);   
        if( ( P_param[2] < global_param[1] ) && ( ( (P_param[0] <= 20) && (P_param[0] >= -20) ) && ( (P_param[1] <= 20) && (P_param[1] >= -20) ) ) )
        {
           // std::cout<<"entering :"<<P_param[2]<<"  removing :"<<global_param[1]<<"\n";
            coords[(int)global_param[1]][0] = P_param[0];
            coords[(int)global_param[1]][1] = P_param[1];
            val[(int)global_param[0]] = P_param[2];
            status = 1;
        }
        
        //std::cout<<index_list[0]<<"  "<<index_list[1]<<"  "<<index_list[2]<<"\n";
        //std::cout<<"I am thread : "<<my_rank<<" and i got flag = "<<i<<"\n";
        
    
       // MPI_Bcast(coords,2*N, MPI_DOUBLE, my_rank, MPI_COMM_WORLD);
       // MPI_Bcast(val,N, MPI_DOUBLE, my_rank, MPI_COMM_WORLD);
       //MPI_Barrier(MPI_COMM_WORLD);
       //MPI_Bcast(&flag,1, MPI_INT, my_rank, MPI_COMM_WORLD);
    } 
    //std::cout<<total_iterations<<"\n";
    
    
    MPI_Finalize();

}


 


  










    /*
    
    if(my_rank == 0)
    {
        
        for(int i = 0;i<N;i++)
        {
            std::cout<<coords[i][0]<<" "<<coords[i][1]<<" "<<temp_val[i]<<"\n";
        }

    }
  */