#include<iostream>
#include<random>
#include<math.h>
#include<algorithm>
#include<fstream>
#include <bits/stdc++.h>
#include "mpi.h"
#include <omp.h>

using namespace std;
MPI_Status status;

void get_Cloud(double * coords,int row, int column)
{
 
    static std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    std::uniform_real_distribution<> dis(-20, 20);
    
    for (int i = 0; i < row; i++) 
    {
        // Use dis to transform the random unsigned int generated by gen into a 
        // double in [20, 20). Each call to dis(gen) generates a new random double
        coords[i*column]  = dis(gen); //X_cord
        coords[i*column + 1] = dis(gen); //Y_cord
    }
}

double Fun(double x, double y)
{
    double temp = 0;
    temp = 1 + pow(sin(x),2) + pow(sin(y),2) - 0.1*exp(-pow(x,2)-pow(y,2));
    return temp; 
}

void get_simplex(int * index_list,int n,int N)
{
    static std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd());        //Standard mersenne_twister_engine seeded with rd()
    std::uniform_real_distribution<> dis(0, N-1);
    for(int i=0;i<=n;i++)
    {
        index_list[i] = std::round(dis(gen));
    }
}

double get_max (double * val, int row) {
    int max_index = 0;
    for(int i = 1; i < row; i++) {
        if(val[i] > val[max_index]) {
            max_index = i;
        }
    }
    return max_index;
}


void Find_new(double * global_param,double * P_param,double * coords,double * val,int * index_list,int column,int row)
{   
    double val_1 = 0,val_2=0,val_3=0,MAX,x_centroid = 0,y_centroid = 0,P_x,P_y,P_val;
    int min_index = 0,max_index = 0,status=0;
    val_1  = val[index_list[0]];                      //value for first point of simplex
    val_2  = val[index_list[1]];                      //value for second point of simplex
    val_3  = val[index_list[2]];                       //value for third point of simplex
  
    MAX = std::max({val_1,val_2,val_3});             //Find max value in simplex
    
    //To find the index of max element among simplex
    for(int i = 0;i<=column;i++)
    {
        if(index_list[i]==MAX)
        {
            max_index = i;
        }
    }
   
   for (int i =0;i<=column;i++)              //Calculate centroid
   { 
          if(i != max_index)
          {
            x_centroid += coords[index_list[i]*column];
            y_centroid += coords[index_list[i]*column + 1];
          }
   }

   x_centroid = x_centroid/(column); y_centroid = y_centroid/(column);
   P_x = 2*x_centroid -  coords[index_list[max_index]*column];           //Calculate point p
   P_y = 2*y_centroid -  coords[index_list[max_index]*column + 1];
   P_val = Fun(P_x,P_y);

   val_1 = get_max(val,row);      //Reusing val_1 to find the index of global maxima 
   val_2 = val[(int)val_1];       //Resuing val_2 to find the value of global maxima 

   global_param[0] = val_1;
   global_param[1] = val_2;       // Assign Value to global param and P_param, which will get returned to function from which they are called
   P_param[0] = P_x;
   P_param[1] = P_y;
   P_param[2] = P_val;
}




int main(int argc, char *argv[])
{

    int         N = 1000;                 /* Number of Point in cluster */
    int         n=2;                      /* Dimension of simplex*/
    int         max_iteration = 10000;    /* Maximum iteration allowed*/
    int         successful_iteration = 0; /* Successfully found a new point*/
    double      coords[N][n] = {0};       /* Define Cloud */
    double      fcoords[N]  = {0};        /* Contain value of clouds*/ 
    int         index_list[n+1] = {0};    /* Contain the list of index choose for simplex */
    int         my_rank;                  /* My process rank           */
    int         p;                        /* The number of processes   */
    int         work_load = 0;            /* Number of Points assigned to each cloud*/
    bool        flag = false;             /* Convergence Flag */
    bool        Point_Found = false;      /* Flag for new point */
    bool        new_max = false;          /* Flag for new max */
    double      diff;                     /* Flag for Convergence */
    double      global_param[2] = {0};    /* For Index and value of global max*/
    double      P_param[3]={0};           /* For x,y, value of new point found*/
    double      P_ext[3]={0};             /* A temp that use to exchange the value of P_param*/
    double      global_min = 0;           /* Global minimum*/ 
    double      wtime = 0;                /* wtime*/
    double      MAX, temp_max;            /* For gloabal max, and a copy to share across proccessor*/
    double      temp_fcoords[N] ={0};     /*A temp that use to exchange the value of fcoords*/


    ofstream myfile(argv[1]);                                    /*File handel for Max-Min */
    ofstream myfile1(argv[2]);                                   /*File handel for min*/                                        
    MPI_Init(&argc, &argv);                                       /* Let the system do what it needs to start up MPI */ 
    MPI_Comm_rank(MPI_COMM_WORLD, &my_rank);                      /* Get my process rank */
    MPI_Comm_size(MPI_COMM_WORLD, &p);                            /* Find out how many processes are being used */
    wtime = omp_get_wtime();                                      /* Start the clock to calculate execution time*/
    if(my_rank==0)
    {
        get_Cloud((double *)coords,N,n);                          /*Generate Cloud if rank 0*/
    }
    MPI_Bcast(coords, N*2, MPI_DOUBLE, 0, MPI_COMM_WORLD);        /*Brodcast the cloud */
    work_load = N/p;                                              /* Compute the workload*/           
    for (int i = 0; i < work_load; i++)                           /* Calculate the value for points in cloud*/
    {                                                             /* by Dividing the work along all proccessor*/
		temp_fcoords[my_rank*work_load + i] = Fun(coords[my_rank*work_load + i][0], coords[my_rank*work_load + i][1]);
	}                                                                                                
	MPI_Allreduce(temp_fcoords, fcoords, N, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);  /*Collect all the value if fcoords*/
    MAX = *max_element(fcoords,fcoords+N);                                         /*Calculate the max element */




    while(!flag && successful_iteration < max_iteration)
    {   
        
        get_simplex(index_list,n,N);                                               /* Get the index for simplex */
        Find_new(global_param,P_param,(double *)coords,fcoords,index_list,n,N);    /* Find New element */
        if( P_param[2] < MAX  && P_param[0] <= 20 && P_param[0] >= -20 && P_param[1] <= 20 && P_param[1] >= -20 ) /*Check that new point is valid or not*/
        {
            coords[(int)global_param[0]][0] = P_param[0];
            coords[(int)global_param[0]][1] = P_param[1];                         /*Update the point and value*/
            fcoords[(int)global_param[0]]   = P_param[2];     
            Point_Found = true; new_max = true; successful_iteration++;         
            for (int i = 0; i < p; i++) 
            {
				if (i != my_rank)
                 {
					MPI_Send(&Point_Found, 1, MPI_CXX_BOOL, i, 100, MPI_COMM_WORLD); /*send new point flag to all other proccessor*/
					MPI_Send(P_param, 3, MPI_DOUBLE, i, 200, MPI_COMM_WORLD);        /*send new point to all other proccessor*/
				 }
			}
            global_min = *min_element(fcoords, fcoords + N);
			myfile<<MAX - global_min<<"\n";                                     /*Write to file */
            myfile1<<global_min<<"\n";                                                    
        }
        else
        {
            Point_Found = false;
            for (int i = 0; i < p; i++)
             {
				if (i != my_rank)
                {
					MPI_Send(&Point_Found, 1, MPI_CXX_BOOL, i, 100, MPI_COMM_WORLD);  /*send new point flag to all other proccessor*/
				}
			}
        }

        for (int i = 0; i < p; i++) {
			if (i != my_rank) {
				MPI_Recv(&Point_Found, 1, MPI_CXX_BOOL, i, 100, MPI_COMM_WORLD, &status);  /*receive new point flag from all other proccessor*/
                if (Point_Found)                                                           /*If point point found recive the point and update the cloud */
                 {
                    new_max = true; successful_iteration++;    
					MPI_Recv(P_ext, 3, MPI_DOUBLE, i, 200, MPI_COMM_WORLD, &status);
					MAX = *max_element(fcoords, fcoords + N);
					for (int k = 0; k < N; k++)
                     {
						if (fcoords[k] == MAX)
                        {
							global_param[0] = k;
							break;
						}
					}
					coords[(int)global_param[0]][0] = P_ext[0]; 
					coords[(int)global_param[0]][1] = P_ext[1];
					fcoords[(int)global_param[0]]   = P_ext[2];
                    global_min = *min_element(fcoords, fcoords + N);
					myfile<<MAX - global_min<<"\n";                                       /*Write to file */
                    myfile1<<global_min<<"\n";
				}
			}
        }

        if (new_max) 
        {
			temp_max = MAX;
			MAX = *max_element(fcoords, fcoords + N);
			diff = fabs(MAX - temp_max)/(MAX);
			if (diff < pow(10, -16) && diff > 0)
            {
				flag = true;
				MPI_Bcast(&flag, 1, MPI_CXX_BOOL, my_rank, MPI_COMM_WORLD);
			}
			new_max = false;
		}
    }
  
    wtime      = omp_get_wtime()-wtime;                                                     /*Stop the clock */
    global_min = *min_element(fcoords, fcoords + N);
    cout << wtime << "|" << global_min << "\n";
    myfile.close();                                                                         /*close the file*/
    myfile1.close();
    MPI_Finalize();
}

























































/*
void update(double * coords,double * fcoords, double * global_param,double * P_param,int N,ofstream & myfile,ofstream &myfile1)
{
            double max,min;
            coords[(int)global_param[0]] = P_param[0];
            coords[(int)global_param[0]+1] = P_param[1];
            fcoords[(int)global_param[0]]   = P_param[2];
            max = *max_element(fcoords,fcoords+N);
            min = *min_element(fcoords,fcoords+N);
            myfile<<max-min<<"\n";
            myfile1<<min<<"\n";
}*/

/*
     if (new_max) {
			temp_max = MAX;
			MAX = *max_element(fcoords, fcoords + N);
			diff = fabs(MAX - temp_max)/(MAX);
			
			if (diff < pow(10, -16) && diff > 0)
            {
				flag = true;
				MPI_Bcast(&flag, 1, MPI_CXX_BOOL, my_rank, MPI_COMM_WORLD);
			}
			new_max = false;
		}
*/